#!/usr/bin/env python
import argparse
import os
import sys
from functools import partial

import parsy

sys.path.insert(0, os.path.abspath(os.path.dirname(os.path.dirname(__file__))))
from megaparsy import char
from megaparsy.char.lexer import (
    indent_block,
    space,
    lexeme as megaparsy_lexeme,
    IndentMany,
    IndentSome,
    line_fold,
    non_indented,
    skip_line_comment,
)


# parser that matches comments beginning with `#`
line_comment = skip_line_comment("#")

# parser which matches whitespace, including newline
scn = space(char.space1, line_comment)

# parser which only matches ' ' and '\t', but *not* newlines
_space1_no_nl = parsy.regex(r'( |\t)+').result('')
sc = space(_space1_no_nl, line_comment)

# factory for parser returning tokens separated by no-newline whitespace
lexeme = partial(megaparsy_lexeme, p_space=sc)

# parser matching lexemes matching [a-zA-Z0-9\-]+
_token = parsy.regex(r'[a-zA-Z0-9\-]+')
p_item_factory = partial(lexeme, _token)
p_item = p_item_factory().desc('list')


# sub-lists
def _line_fold_callback(sc_):
    """
    "The second argument to `line_fold` is a callback that receives a
     custom space-consuming parser as argument."

    Args:
        sc_: this space-consumer is generated by line_fold internals
            to handle indentation
    """
    @parsy.generate
    def _line_fold_callback_inner():
        """
        My understanding of the Haskell original of this callback is:
        taking a list of `p_item`-like tokens found at current-or-greater
        indent and joining them with ' '
        """
        items = yield megaparsy_lexeme(_token, p_space=sc_).at_least(1)
        return ' '.join(items)

    return _line_fold_callback_inner << sc


p_line_fold = line_fold(scn, _line_fold_callback)


@parsy.generate
def _complex_item_block():
    header = yield p_item
    return IndentMany(indent=None, f=lambda val: (header, val), p=p_line_fold)


# parser matching list item and its indented children
p_complex_item = indent_block(scn, _complex_item_block)


@parsy.generate
def _item_list_block():
    """
    return (L.IndentSome Nothing (return . (header, )) pComplexItem)

    (return . (header, ))
            ^ means 'function composition'
    """
    header = yield p_item
    return IndentSome(indent=None, f=lambda val: (header, val), p=p_complex_item)


# parser matching a collection of list items, begins non-indented, ends non-indented
# i.e. a whole list
p_item_list = non_indented(scn, indent_block(scn, _item_list_block))


# document is a collection of lists
parser = p_item_list << parsy.eof


if __name__ == "__main__":
    argparser = argparse.ArgumentParser()
    argparser.add_argument(
        'file_to_parse',
        default=sys.stdin,
        type=argparse.FileType('r'),
        nargs='?',
    )
    args = argparser.parse_args()

    input_ = args.file_to_parse.read()
    # print(input_)

    val = parser.parse(input_)
    print(val)
